"use client";

import { ethers } from "ethers";
import {
  RefObject,
  useCallback,
  useEffect,
  useMemo,
  useRef,
  useState,
} from "react";

import { FhevmInstance } from "@/fhevm/fhevmTypes";
import { FhevmDecryptionSignature } from "@/fhevm/FhevmDecryptionSignature";
import { GenericStringStorage } from "@/fhevm/GenericStringStorage";

/*
  The following two files are automatically generated by the script located at 
  <root>/frontend/scripts/genabi.mjs. This script parses the 
  <root>/deployments directory to retrieve deployment information for StudySchedule.sol:
  
  - <root>/frontend/abi/StudyScheduleABI.ts
  - <root>/frontend/abi/StudyScheduleAddresses.ts
*/
import { StudyScheduleAddresses } from "@/abi/StudyScheduleAddresses";
import { StudyScheduleABI } from "@/abi/StudyScheduleABI";

export type ClearValueType = {
  handle: string;
  clear: string | bigint | boolean;
};

type StudyScheduleInfoType = {
  abi: typeof StudyScheduleABI.abi;
  address?: `0x${string}`;
  chainId?: number;
  chainName?: string;
};

/**
 * Resolves StudySchedule contract metadata for the given EVM `chainId`.
 */
function getStudyScheduleByChainId(
  chainId: number | undefined
): StudyScheduleInfoType {
  if (!chainId) {
    return { abi: StudyScheduleABI.abi };
  }

  const entry =
    StudyScheduleAddresses[chainId.toString() as keyof typeof StudyScheduleAddresses];

  if (!entry || !("address" in entry) || entry.address === ethers.ZeroAddress) {
    return { abi: StudyScheduleABI.abi, chainId };
  }

  return {
    address: entry?.address as `0x${string}` | undefined,
    chainId: entry?.chainId ?? chainId,
    chainName: entry?.chainName,
    abi: StudyScheduleABI.abi,
  };
}

export const useStudySchedule = (parameters: {
  instance: FhevmInstance | undefined;
  fhevmDecryptionSignatureStorage: GenericStringStorage;
  eip1193Provider: ethers.Eip1193Provider | undefined;
  chainId: number | undefined;
  ethersSigner: ethers.JsonRpcSigner | undefined;
  ethersReadonlyProvider: ethers.ContractRunner | undefined;
  sameChain: RefObject<(chainId: number | undefined) => boolean>;
  sameSigner: RefObject<
    (ethersSigner: ethers.JsonRpcSigner | undefined) => boolean
  >;
}) => {
  const {
    instance,
    fhevmDecryptionSignatureStorage,
    chainId,
    ethersSigner,
    ethersReadonlyProvider,
    sameChain,
    sameSigner,
  } = parameters;

  // States + Refs
  const [targetGoalsHandle, setTargetGoalsHandle] = useState<string | undefined>(undefined);
  const [completedGoalsHandle, setCompletedGoalsHandle] = useState<string | undefined>(undefined);
  const [completionRateHandle, setCompletionRateHandle] = useState<string | undefined>(undefined);
  const [avgPriorityHandle, setAvgPriorityHandle] = useState<string | undefined>(undefined);
  
  const [decryptedTargetGoals, setDecryptedTargetGoals] = useState<ClearValueType | undefined>(undefined);
  const [decryptedCompletedGoals, setDecryptedCompletedGoals] = useState<ClearValueType | undefined>(undefined);
  const [decryptedCompletionRate, setDecryptedCompletionRate] = useState<ClearValueType | undefined>(undefined);
  const [decryptedAvgPriority, setDecryptedAvgPriority] = useState<ClearValueType | undefined>(undefined);
  
  const [isRefreshing, setIsRefreshing] = useState<boolean>(false);
  const [isDecrypting, setIsDecrypting] = useState<boolean>(false);
  const [isSubmitting, setIsSubmitting] = useState<boolean>(false);
  const [message, setMessage] = useState<string>("");
  const [currentDate, setCurrentDate] = useState<number | undefined>(undefined);
  const [ethersProvider, setEthersProvider] = useState<ethers.JsonRpcProvider | undefined>(undefined);

  const studyScheduleRef = useRef<StudyScheduleInfoType | undefined>(undefined);
  const isRefreshingRef = useRef<boolean>(isRefreshing);
  const isDecryptingRef = useRef<boolean>(isDecrypting);
  const isSubmittingRef = useRef<boolean>(isSubmitting);

  // Get EIP1193 provider
  const eip1193Provider = useCallback(() => {
    if (chainId === 31337) {
      return "http://localhost:8545";
    }
    if (parameters.eip1193Provider) {
      return parameters.eip1193Provider;
    }
    if (typeof window !== "undefined" && (window as any).ethereum) {
      return (window as any).ethereum;
    }
    return undefined;
  }, [chainId, parameters.eip1193Provider]);

  // Set up ethers provider if provided
  useEffect(() => {
    if (parameters.ethersReadonlyProvider) {
      setEthersProvider(parameters.ethersReadonlyProvider as ethers.JsonRpcProvider);
    }
  }, [parameters.ethersReadonlyProvider]);

  // StudySchedule contract
  const studySchedule = useMemo(() => {
    const c = getStudyScheduleByChainId(chainId);
    studyScheduleRef.current = c;
    // Only show error when chainId is known but contract is actually not deployed, avoiding false positives for chainId=undefined
    if (!c.address && chainId !== undefined) {
      setMessage(`StudySchedule deployment not found for chainId=${chainId}.`);
    }
    return c;
  }, [chainId]);

  const isDeployed = useMemo(() => {
    if (!studySchedule) {
      return undefined;
    }
    return (
      Boolean(studySchedule.address) && studySchedule.address !== ethers.ZeroAddress
    );
  }, [studySchedule]);

  const canRefresh = useMemo(() => {
    return studySchedule.address && ethersReadonlyProvider && !isRefreshing && currentDate !== undefined;
  }, [studySchedule.address, ethersReadonlyProvider, isRefreshing, currentDate]);

  const canSubmit = useMemo(() => {
    return (
      studySchedule.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isSubmitting
    );
  }, [studySchedule.address, instance, ethersSigner, isRefreshing, isSubmitting]);

  const canDecrypt = useMemo((): boolean => {
    return Boolean(
      studySchedule.address &&
      instance &&
      ethersSigner &&
      !isRefreshing &&
      !isDecrypting &&
      (targetGoalsHandle || completedGoalsHandle || completionRateHandle || avgPriorityHandle) &&
      currentDate !== undefined
    );
  }, [
    studySchedule.address,
    instance,
    ethersSigner,
    isRefreshing,
    isDecrypting,
    targetGoalsHandle,
    completedGoalsHandle,
    completionRateHandle,
    avgPriorityHandle,
    currentDate,
  ]);

  // Refresh schedule handles
  const refreshSchedule = useCallback((date: number) => {
    if (isRefreshingRef.current) {
      return;
    }

    if (
      !studyScheduleRef.current ||
      !studyScheduleRef.current?.chainId ||
      !studyScheduleRef.current?.address ||
      !ethersReadonlyProvider ||
      !ethersSigner
    ) {
      setTargetGoalsHandle(undefined);
      setCompletedGoalsHandle(undefined);
      setCompletionRateHandle(undefined);
      setAvgPriorityHandle(undefined);
      return;
    }

    isRefreshingRef.current = true;
    setIsRefreshing(true);
    setCurrentDate(date);

    const thisChainId = studyScheduleRef.current.chainId;
    const thisStudyScheduleAddress = studyScheduleRef.current.address;
    const thisEthersSigner = ethersSigner;

    const thisStudyScheduleContract = new ethers.Contract(
      thisStudyScheduleAddress,
      studyScheduleRef.current.abi,
      ethersReadonlyProvider
    );

    Promise.all([
      thisStudyScheduleContract.getEncryptedTargetGoals(thisEthersSigner.address, date).catch(() => ethers.ZeroHash),
      thisStudyScheduleContract.getEncryptedCompletedGoals(thisEthersSigner.address, date).catch(() => ethers.ZeroHash),
      thisStudyScheduleContract.getEncryptedCompletionRateData(thisEthersSigner.address, date).then(([completed, target]) => completed).catch(() => ethers.ZeroHash),
      thisStudyScheduleContract.getEncryptedAveragePriorityData(thisEthersSigner.address, date).then(([total, count]) => total).catch(() => ethers.ZeroHash),
    ])
      .then(([target, completed, rate, priority]) => {
        if (
          sameChain.current(thisChainId) &&
          thisStudyScheduleAddress === studyScheduleRef.current?.address
        ) {
          setTargetGoalsHandle(target);
          setCompletedGoalsHandle(completed);
          setCompletionRateHandle(rate);
          setAvgPriorityHandle(priority);
        }
      })
      .catch((e) => {
        setMessage("StudySchedule.getEncrypted*() call failed! error=" + e);
      })
      .finally(() => {
        isRefreshingRef.current = false;
        setIsRefreshing(false);
      });
  }, [ethersReadonlyProvider, ethersSigner, sameChain]);

  // Decrypt schedule
  const decryptSchedule = useCallback(
    async (date: number) => {
      if (!studySchedule.address || !ethersProvider || !instance || !ethersSigner || !ethersSigner.address) {
        setMessage("Missing requirements for decryption");
        return;
      }

      if (!targetGoalsHandle && !completedGoalsHandle && !completionRateHandle && !avgPriorityHandle) {
        setMessage("No encrypted data available to decrypt");
        return;
      }

      try {
        setIsDecrypting(true);
        setMessage("Checking permissions and fetching latest encrypted data...");

        // First, verify user has data and get the latest encrypted handles from contract
        const contract = new ethers.Contract(studySchedule.address, studySchedule.abi, ethersProvider);

        // Get the latest encrypted data from contract (not from state, to ensure it's current)
        const targetHandle = await contract.getEncryptedTargetGoals(ethersSigner.address, date).catch(() => ethers.ZeroHash);
        const completedHandle = await contract.getEncryptedCompletedGoals(ethersSigner.address, date).catch(() => ethers.ZeroHash);
        const [completedForRate, targetForRate] = await contract.getEncryptedCompletionRateData(ethersSigner.address, date).catch(() => [ethers.ZeroHash, ethers.ZeroHash]);
        const [totalPriority, priorityCount] = await contract.getEncryptedAveragePriorityData(ethersSigner.address, date).catch(() => [ethers.ZeroHash, ethers.ZeroHash]);

        // Prepare handles for decryption
        const handleContractPairs: Array<{ handle: string; contractAddress: `0x${string}` }> = [];

        if (targetHandle && targetHandle !== ethers.ZeroHash) {
          handleContractPairs.push({ handle: targetHandle, contractAddress: studySchedule.address as `0x${string}` });
        }
        if (completedHandle && completedHandle !== ethers.ZeroHash) {
          handleContractPairs.push({ handle: completedHandle, contractAddress: studySchedule.address as `0x${string}` });
        }
        if (completedForRate && completedForRate !== ethers.ZeroHash) {
          handleContractPairs.push({ handle: completedForRate, contractAddress: studySchedule.address as `0x${string}` });
        }
        if (targetForRate && targetForRate !== ethers.ZeroHash) {
          handleContractPairs.push({ handle: targetForRate, contractAddress: studySchedule.address as `0x${string}` });
        }
        if (totalPriority && totalPriority !== ethers.ZeroHash) {
          handleContractPairs.push({ handle: totalPriority, contractAddress: studySchedule.address as `0x${string}` });
        }
        if (priorityCount && priorityCount !== ethers.ZeroHash) {
          handleContractPairs.push({ handle: priorityCount, contractAddress: studySchedule.address as `0x${string}` });
        }

        if (handleContractPairs.length === 0) {
          throw new Error("No valid encrypted data found. Please add schedule data first before decrypting.");
        }

        console.log("[useStudySchedule] ===== Decryption Debug Info =====");
        console.log("[useStudySchedule] Contract address:", studySchedule.address);
        console.log("[useStudySchedule] User address:", ethersSigner.address);
        console.log("[useStudySchedule] Chain ID:", chainId);
        console.log("[useStudySchedule] Handles to decrypt:", handleContractPairs.length);

        setMessage("Decrypting schedule data...");

        // Generate keypair for EIP712 signature
        let keypair: { publicKey: Uint8Array; privateKey: Uint8Array };
        if (typeof (instance as any).generateKeypair === "function") {
          keypair = (instance as any).generateKeypair();
        } else {
          keypair = {
            publicKey: new Uint8Array(32).fill(0),
            privateKey: new Uint8Array(32).fill(0),
          };
        }

        // Create EIP712 signature for decryption
        const contractAddresses = [studySchedule.address as `0x${string}`];
        const startTimestamp = Math.floor(Date.now() / 1000).toString();
        const durationDays = "10";

        let eip712: any;
        if (typeof (instance as any).createEIP712 === "function") {
          eip712 = (instance as any).createEIP712(
            keypair.publicKey,
            contractAddresses,
            startTimestamp,
            durationDays
          );
        } else {
          eip712 = {
            domain: {
              name: "FHEVM",
              version: "1",
              chainId: chainId,
              verifyingContract: contractAddresses[0],
            },
            types: {
              UserDecryptRequestVerification: [
                { name: "publicKey", type: "bytes" },
                { name: "contractAddresses", type: "address[]" },
                { name: "startTimestamp", type: "string" },
                { name: "durationDays", type: "string" },
              ],
            },
            message: {
              publicKey: ethers.hexlify(keypair.publicKey),
              contractAddresses,
              startTimestamp,
              durationDays,
            },
          };
        }

        // Sign the EIP712 message
        const signature = await ethersSigner.signTypedData(
          eip712.domain,
          { UserDecryptRequestVerification: eip712.types.UserDecryptRequestVerification },
          eip712.message
        );

        // For local mock network, signature may need to have "0x" prefix removed
        const signatureForDecrypt = chainId === 31337
          ? signature.replace("0x", "")
          : signature;

        console.log("[useStudySchedule] Decrypting with:", {
          handleCount: handleContractPairs.length,
          contractAddress: studySchedule.address,
          userAddress: ethersSigner.address,
          chainId,
          signatureLength: signature.length,
          signatureForDecryptLength: signatureForDecrypt.length,
        });

        // Decrypt using userDecrypt method
        const decryptedResult = await (instance as any).userDecrypt(
          handleContractPairs,
          keypair.privateKey,
          keypair.publicKey,
          signatureForDecrypt,
          contractAddresses,
          ethersSigner.address as `0x${string}`,
          startTimestamp,
          durationDays
        );

        console.log("[useStudySchedule] Decryption successful");

        // Update decrypted values
        if (targetHandle && targetHandle !== ethers.ZeroHash && decryptedResult[targetHandle] !== undefined) {
          setDecryptedTargetGoals({ handle: targetHandle, clear: decryptedResult[targetHandle] });
        }
        if (completedHandle && completedHandle !== ethers.ZeroHash && decryptedResult[completedHandle] !== undefined) {
          setDecryptedCompletedGoals({ handle: completedHandle, clear: decryptedResult[completedHandle] });
        }
        if (completedForRate && completedForRate !== ethers.ZeroHash && decryptedResult[completedForRate] !== undefined) {
          setDecryptedCompletionRate({ handle: completedForRate, clear: decryptedResult[completedForRate] });
        }
        if (totalPriority && totalPriority !== ethers.ZeroHash && decryptedResult[totalPriority] !== undefined) {
          setDecryptedAvgPriority({ handle: totalPriority, clear: decryptedResult[totalPriority] });
        }

        // Update state with latest handles for future operations
        setTargetGoalsHandle(targetHandle);
        setCompletedGoalsHandle(completedHandle);
        setCompletionRateHandle(completedForRate);
        setAvgPriorityHandle(totalPriority);

        setMessage("Schedule decrypted successfully!");
      } catch (error: any) {
        console.error("[useStudySchedule] Error decrypting schedule:", error);
        const errorMessage = error.message || String(error);

        // Provide more helpful error messages
        if (errorMessage.includes("not authorized") || errorMessage.includes("authorized")) {
          setMessage(`Decryption failed: You don't have permission to decrypt this data. This may happen if:
1. The contract was redeployed and the data is from an old deployment
2. You haven't added schedule data yet
3. The transaction hasn't fully confirmed yet

Please try:
1. Add schedule data again to get new encrypted data with proper permissions
2. Wait a few seconds after adding data before decrypting
3. Refresh the page and try again`);
        } else {
          setMessage(`Error decrypting: ${errorMessage}`);
        }
        throw error;
      } finally {
        setIsDecrypting(false);
      }
    },
    [
      studySchedule.address,
      studySchedule.abi,
      ethersProvider,
      instance,
      ethersSigner,
      chainId,
      targetGoalsHandle,
      completedGoalsHandle,
      completionRateHandle,
      avgPriorityHandle,
    ]
  );

  // Create or update schedule
  const createOrUpdateSchedule = useCallback(
    async (date: number, targetGoals: number, completedGoals: number, priority: number) => {
      console.log("[useStudySchedule] createOrUpdateSchedule called", {
        date,
        targetGoals,
        completedGoals,
        priority,
        contractAddress: studySchedule.address,
        hasEthersSigner: !!ethersSigner,
        hasFhevmInstance: !!instance,
        hasEthersProvider: !!ethersProvider,
      });

      if (!studySchedule.address) {
        const error = new Error("Contract address not configured. Please set VITE_CONTRACT_ADDRESS in .env.local");
        setMessage(error.message);
        console.error("[useStudySchedule] Missing contract address");
        throw error;
      }

      if (!ethersSigner) {
        const error = new Error("Wallet signer not available. Please ensure your wallet is connected.");
        setMessage(error.message);
        console.error("[useStudySchedule] Missing ethers signer");
        throw error;
      }

      if (!instance) {
        const error = new Error("FHEVM instance not initialized. Please wait for initialization.");
        setMessage(error.message);
        console.error("[useStudySchedule] Missing FHEVM instance");
        throw error;
      }

      if (!ethersProvider) {
        const error = new Error("Ethers provider not available.");
        setMessage(error.message);
        console.error("[useStudySchedule] Missing ethers provider");
        throw error;
      }

      if (targetGoals < 1 || completedGoals < 0 || priority < 1 || priority > 3) {
        const error = new Error("Invalid input values: target goals must be >= 1, completed goals must be >= 0, priority must be 1-3");
        setMessage(error.message);
        throw error;
      }

      try {
        setIsSubmitting(true);
        setMessage("Encrypting schedule data...");

        // Verify contract is deployed
        const contractCode = await ethersProvider.getCode(studySchedule.address);
        if (contractCode === "0x" || contractCode.length <= 2) {
          throw new Error(`Contract not deployed at ${studySchedule.address}. Please deploy the contract first.`);
        }

        const contract = new ethers.Contract(studySchedule.address, studySchedule.abi, ethersSigner);

        // Encrypt the inputs using FHEVM
        const encryptedInput = instance.createEncryptedInput(
          studySchedule.address as `0x${string}`,
          ethersSigner.address as `0x${string}`
        );
        encryptedInput.add32(targetGoals);
        encryptedInput.add32(completedGoals);
        encryptedInput.add32(priority);
        const encrypted = await encryptedInput.encrypt();
        console.log("[useStudySchedule] Encryption complete", {
          hasHandles: !!encrypted.handles && encrypted.handles.length > 0,
          hasInputProof: !!encrypted.inputProof && encrypted.inputProof.length > 0,
        });

        setMessage("Submitting to blockchain...");

        const encryptedTargetHandle = encrypted.handles[0];
        const encryptedCompletedHandle = encrypted.handles[1];
        const encryptedPriorityHandle = encrypted.handles[2];

        if (!encryptedTargetHandle || !encryptedCompletedHandle || !encryptedPriorityHandle || !encrypted.inputProof || encrypted.inputProof.length === 0) {
          throw new Error("Encryption failed - missing handles or proof");
        }

        console.log("[useStudySchedule] Submitting transaction...");
        const tx = await contract.createOrUpdateSchedule(
          date,
          encryptedTargetHandle,
          encryptedCompletedHandle,
          encryptedPriorityHandle,
          encrypted.inputProof,
          {
            gasLimit: 5000000,
          }
        );
        console.log("[useStudySchedule] Transaction sent:", tx.hash);
        const receipt = await tx.wait();
        console.log("[useStudySchedule] Transaction confirmed, block:", receipt.blockNumber);

        setMessage("Schedule updated successfully! Refreshing data...");

        // Wait a bit for the state to be fully updated and permissions to be set
        console.log("[useStudySchedule] Waiting for state update and permissions...");
        await new Promise(resolve => setTimeout(resolve, 2000));

        // Refresh the schedule data
        refreshSchedule(date);
        setMessage("Schedule updated successfully!");
      } catch (error: any) {
        const errorMessage = error.reason || error.message || String(error);
        setMessage(`Error: ${errorMessage}`);
        console.error("[useStudySchedule] Error updating schedule:", error);
        throw error;
      } finally {
        setIsSubmitting(false);
      }
    },
    [
      studySchedule.address,
      studySchedule.abi,
      ethersSigner,
      instance,
      ethersProvider,
      refreshSchedule,
    ]
  );

  return {
    contractAddress: studySchedule.address,
    isDeployed,
    canRefresh,
    canSubmit,
    canDecrypt,
    createOrUpdateSchedule,
    decryptSchedule,
    refreshSchedule,
    message,
    isRefreshing,
    isDecrypting,
    isSubmitting,
    decryptedTargetGoals: decryptedTargetGoals?.clear,
    decryptedCompletedGoals: decryptedCompletedGoals?.clear,
    decryptedCompletionRate: decryptedCompletionRate?.clear,
    decryptedAvgPriority: decryptedAvgPriority?.clear,
  };
};

